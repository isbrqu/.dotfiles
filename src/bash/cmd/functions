_open() {
    local file="$1"
    xdg-open "$file" &> /dev/null &
    (( $? == 0 )) && disown
}

open() {
    local file="$1"
    if [[ -n "$file" ]];then
        _open "$file"
    else
        file="$(find -type f | fzf --height=50%)"
        # file="$(fzf --height=50%)"
        if [[ "$file" != "" ]];then
            _open "$file"
        fi
    fi
}

_docker_search() {
    local query="$1"
    local type="${2-image}"
    local -r URL="$URL_DOCKER_SEARCH"
    local url="$URL?q=$query&type=$type"
    open "$url"
}

envup() {
    while IFS='=' read -r name value || [[ -n "$line" ]];do
        export "$name"="$value"
    done < ".env"
}

l() {
    if [[ -f "$1" ]];then
        # read a file
        bat "$1" || cat "$1"
    elif [[ -z "$1" ]];then
        # list all file
        ls -1 $LS_OPTS
    else
        # list folder contents
        ls -1 $LS_OPTS "$1"
    fi
}

prev_cd() {
    if [[ -n $1 ]];then
        local -i n=$1
        for ((i=1; i<=n; i++));do
            cd ..
        done
    else
        cd ..
    fi
}

v() {
    if [[ -n "$1" ]];then
        vim "$1"
    elif [[ -n "$TMUX" ]];then
        local file
        file="$(fzf-tmux -p)"\
        && vim "$file"
    else
        local file
        file="$(fzf)"\
        && vim "$file"
    fi
}

disable_inputs() {
    declare name="ILITEK ILITEK Multi-Touch"
    declare state
    state="$(IFS=$'\n'; arr=($(xinput list-props "$name")); echo "${arr[1]}")"
    if [[ "$state" = *1 ]];then
        xinput disable "$name"
    fi
}

load_startx() {
    if [[ "$(tty)" = /dev/tty1 && -z "$TMUX" ]];then
        startx
    fi
}

load_config_hardware() {
    if [[ "$(tty)" == */pts/* && -z "$TMUX" ]];then
        disable_inputs
    fi
}

tmux_start() {
    if [[ -n "$TMUX" ]];then
        echo "error (1): the session is already started"
        return 1
    fi
    tmux attach-session -t "home"
}


extract() {
 if [[ -z "$1" ]]; then
    # display usage if no parameters given
    echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
 else
    if [[ -f "$1" ]] ; then
        # NAME="${1%.*}"
        # mkdir $NAME && cd $NAME
        case "$1" in
          *.tar.bz2)   tar xvjf ./"$1"    ;;
          *.tar.gz)    tar xvzf ./"$1"    ;;
          *.tar.xz)    tar xvJf ./"$1"    ;;
          *.lzma)      unlzma ./"$1"      ;;
          *.bz2)       bunzip2 ./"$1"     ;;
          *.rar)       unrar x -ad ./"$1" ;;
          *.gz)        gunzip ./"$1"      ;;
          *.tar)       tar xvf ./"$1"     ;;
          *.tbz2)      tar xvjf ./"$1"    ;;
          *.tgz)       tar xvzf ./"$1"    ;;
          *.zip)       unzip ./"$1"       ;;
          *.Z)         uncompress ./"$1"  ;;
          *.7z)        7z x ./"$1"        ;;
          *.xz)        unxz ./"$1"        ;;
          *.exe)       cabextract ./"$1"  ;;
          *)           echo "extract: '$1' - unknown archive method" ;;
        esac
    else
        echo "$1 - file does not exist"
    fi
fi
}

renhash() {
    local filename="${1}"
    local extension
    local new_filename
    # verifica si el archivo a nombre existe
    if [[ ! -f "${filename}" ]];then
        echo "error (1): ${filename} doesn't exist"
        return 1
    fi
    hash_and_filename="$(sha1sum "${filename}")"
    hash="${hash_and_filename%% *}"
    new_filename="sha1-${hash}"
    # verifica si tiene extension
    if [[ "${filename}" == *.* ]];then
        extension="${filename##*.}"
        new_filename="${new_filename}.${extension}"
    fi
    # verifica si el archivo nuevo ya existe
    if [[ -f "${new_filename}" ]];then
        echo "error (1): ${new_filename} exists"
        return 1
    fi
    mv --no-clobber "${filename}" "${new_filename}"
}

# helpers
tldr() {
    curl "tldr.monster/${1}"
}

cht() {
    local lang="$1"
    local help="$2"
    curl "cht.sh/${lang}/${help}"
}

colors256() {
        local c i j
        printf "Colors 0 to 15 for the standard 16 colors\n"
        for ((c = 0; c < 16; c++)); do
                printf "|%s%3d%s" "$(tput setaf "$c")" "$c" "$(tput sgr0)"
        done
        printf "|\n\n"
        printf "Colors 16 to 231 for 256 colors\n"
        for ((i = j = 0; c < 232; c++, i++)); do
                printf "|"
                ((i > 5 && (i = 0, ++j))) && printf " |"
                ((j > 5 && (j = 0, 1)))   && printf "\b \n|"
                printf "%s%3d%s" "$(tput setaf "$c")" "$c" "$(tput sgr0)"
        done
        printf "|\n\n"
        printf "Greyscale 232 to 255 for 256 colors\n"
        for ((; c < 256; c++)); do
                printf "|%s%3d%s" "$(tput setaf "$c")" "$c" "$(tput sgr0)"
        done
        printf "|\n"
}
