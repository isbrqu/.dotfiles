_open() {
    local file="$1"
    xdg-open "$file" &> /dev/null &
    (( $? == 0 )) && disown
}

open() {
    local file="$1"
    if [[ -n "$file" ]];then
        _open "$file"
    else
        file="$(find -type f | fzf --height=50%)"
        # file="$(fzf --height=50%)"
        if [[ "$file" != "" ]];then
            _open "$file"
        fi
    fi
}

_docker_search() {
    local query="$1"
    local type="${2-image}"
    local -r URL="$URL_DOCKER_SEARCH"
    local url="$URL?q=$query&type=$type"
    open "$url"
}

envup() {
    while IFS='=' read -r name value || [[ -n "$line" ]];do
        export "$name"="$value"
    done < ".env"
}

l() {
    if [[ -f "$1" ]];then
        # read a file
        bat "$1" || cat "$1"
    elif [[ -z "$1" ]];then
        # list all file
        ls -1 $LS_OPTS
    else
        # list folder contents
        ls -1 $LS_OPTS "$1"
    fi
}

prev_cd() {
    if [[ -n $1 ]];then
        local -i n=$1
        for ((i=1; i<=n; i++));do
            cd ..
        done
    else
        cd ..
    fi
}

v() {
    if [[ -n "$1" ]];then
        vim "$1"
    elif [[ -n "$TMUX" ]];then
        local file
        file="$(fzf-tmux -p)"\
        && vim "$file"
    else
        local file
        file="$(fzf)"\
        && vim "$file"
    fi
}

disable_inputs() {
    declare name="ILITEK ILITEK Multi-Touch"
    declare state
    state="$(IFS=$'\n'; arr=($(xinput list-props "$name")); echo "${arr[1]}")"
    if [[ "$state" = *1 ]];then
        xinput disable "$name"
    fi
}

load_bash_color() {
    # enable color support of ls and also add handy aliases
    if [[ -x /usr/bin/dircolors ]];then
        if [[ -r ~/.dircolors ]];then
            eval "$(dircolors --bourne-shell ~/.dircolors)"
        else
            eval "$(dircolors --bourne-shell)"
        fi
    fi
}

load_bash_completion() {
    # enable programmable completion features (you don't need to enable
    # this, if it's already enabled in /etc/bash.bashrc and /etc/profile
    # sources /etc/bash.bashrc).
    if ! shopt -oq posix; then
        if [[ -f /usr/share/bash-completion/bash_completion ]];then
            . /usr/share/bash-completion/bash_completion
        elif [[ -f /etc/bash_completion ]];then
            . /etc/bash_completion
        fi
    fi
    # personal
    if [[ $- == *i* ]];then
        for file in "$BASH_PATH/completion-"*;do
            . "$file"
        done
    fi
}

load_bash_key_bindings() {
    for file in "$BASH_PATH/key-bindings-"*;do
        . "$file"
    done
}

load_startx() {
    if [[ "$(tty)" = /dev/tty1 && -z "$TMUX" ]];then
        startx
    fi
}

load_config_hardware() {
    if [[ "$(tty)" == */pts/* && -z "$TMUX" ]];then
        disable_inputs
    fi
}

tmux_start() {
    if [[ -n "$TMUX" ]];then
        echo "error (1): the session is already started"
        return 1
    fi
    tmux attach-session -t "home"
}

load_tmux() {
    if [[ "$(tty)" == */pts/* ]];then
        if [[ -z "$TMUX" ]];then
            for folder in "$HOME"/w/*/;do
                name="${folder%%/}"
                name="${name##*/}"
                tmux has-session -t "$name-" &> /dev/null
                if (( $? != 0 ));then
                    tmux new-session -d -c "$folder" -t "$name"
                fi
            done
            tmux_start
        fi
    fi
}

extract() {
 if [[ -z "$1" ]]; then
    # display usage if no parameters given
    echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
 else
    if [[ -f "$1" ]] ; then
        # NAME="${1%.*}"
        # mkdir $NAME && cd $NAME
        case "$1" in
          *.tar.bz2)   tar xvjf ./"$1"    ;;
          *.tar.gz)    tar xvzf ./"$1"    ;;
          *.tar.xz)    tar xvJf ./"$1"    ;;
          *.lzma)      unlzma ./"$1"      ;;
          *.bz2)       bunzip2 ./"$1"     ;;
          *.rar)       unrar x -ad ./"$1" ;;
          *.gz)        gunzip ./"$1"      ;;
          *.tar)       tar xvf ./"$1"     ;;
          *.tbz2)      tar xvjf ./"$1"    ;;
          *.tgz)       tar xvzf ./"$1"    ;;
          *.zip)       unzip ./"$1"       ;;
          *.Z)         uncompress ./"$1"  ;;
          *.7z)        7z x ./"$1"        ;;
          *.xz)        unxz ./"$1"        ;;
          *.exe)       cabextract ./"$1"  ;;
          *)           echo "extract: '$1' - unknown archive method" ;;
        esac
    else
        echo "$1 - file does not exist"
    fi
fi
}

renhash() {
    local filename="${1}"
    local extension
    local new_filename
    # verifica si el archivo a nombre existe
    if [[ ! -f "${filename}" ]];then
        echo "error (1): ${filename} doesn't exist"
        return 1
    fi
    hash_and_filename="$(sha1sum "${filename}")"
    hash="${hash_and_filename%% *}"
    new_filename="sha1-${hash}"
    # verifica si tiene extension
    if [[ "${filename}" == *.* ]];then
        extension="${filename##*.}"
        new_filename="${new_filename}.${extension}"
    fi
    # verifica si el archivo nuevo ya existe
    if [[ -f "${new_filename}" ]];then
        echo "error (1): ${new_filename} exists"
        return 1
    fi
    mv --no-clobber ${filename} ${new_filename}
}

# util
tldr() {
    curl "tldr.monster/${1}"
}

cht() {
    local lang="$1"
    local help="$2"
    curl "cht.sh/${lang}/${help}"
}
